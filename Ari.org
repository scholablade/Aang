#+title: Design and Implementation of the Ari Programming Language
* Getting Started
* Licenses
* Motivation / Goals
** Writing in Denotional Relational Literate Programming
** A Malleable Programming Language
* Design
** Functionality
Ari is a simply typed lambda calculus (STLC) (for now), typically STLC has 2 base types and 4 expressions.
We follow the paper[fn:1], which defines the following types and expressions.
*** For types:
- Base Type
- Function Type
*** For Expressions:
- Variables
- Abstractions
- Applications
- Constructors
- Pair
- Fst
- Snd
- Unit
** Specification
*** Types
Since we use a subset of Haskell's type system we don't have to do much if at all, this approach is called higher-order abstract syntax (HOAS).
*** Expressions
**** Variables
Similar as in the types heading we can also use Haskell's variable semantics therefore we don't have to specify variables in our language.
**** Abstractions
Abstractions correspond to function definitions, which we can think of as a function that takes an indentifier and an expression:
#+begin_src haskell
abstraction :: wrap (a, h) b -> wrap env (a -> b)
#+end_src
**** Application
Application is just function application and can be specified as:
#+begin_src haskell
application :: wrap env (a -> b) -> wrap env a -> wrap env b
#+end_src
**** Constructors
Constructors are the builders of types, therefore their specification must not consume anything:
#+begin_src haskell
const :: wrap (a, h) a
#+end_src
**** Pair
Pair is the combination of two types, in Haskell it is the ~(,)~ type.
#+begin_src haskell
pair :: wrap env a -> wrap env b -> wrap env (a, b)
#+end_src
**** Fst
fst is grabbing the first value of the pair type.
#+begin_src haskell
fst :: wrap env (a, b) -> wrap env a
#+end_src
**** Snd
Snd is identical to Fst except it grabs the second value.
#+begin_src haskell
snd :: wrap env (a, b) -> wrap env b
#+end_src
*** The full picture
The full API:
#+begin_src haskell
wrap env a
application :: wrap env (a -> b) -> wrap env a -> wrap env b
abstraction :: wrap (a, h) b -> wrap env (a -> b)
const :: wrap (a, h) a
pair :: wrap env a -> wrap env b -> wrap env (a, b)
fst :: wrap env (a, b) -> wrap env a
snd :: wrap env (a, b) -> wrap env b
#+end_src
** Denotation

We are going to make semantic functions that map the lambda calculus world to /a/ closed cartesian category, first we have to define the semantic domain though. 
Regardless, we will only make a denotation for the typeclass (let's call it Lambda), Abstractions, Applications and Constructors since we are only introducing those primitives while everything else is for free for us by HOAS.
*** Types
**** The Semantic Domain: The Function Category
You can pick any closed cartesian category really but the function category is simple, an instance comes with the library itself and the lambda calculus is generally a theory of computation of functions so it works out.
So let's model it.
#+begin_src haskell
type Function = (->)
⟦_⟧ :: Lambda (wrap a b) => wrap a b -> (a -> b)
#+end_src
*** Expressions
**** Abstractions
***** Curry
Curry is a higher-order function that takes in a function: ~(a, b) -> c~ and curries it to be: ~a -> b -> c~.
It's notion in the CCC is the closed part focusing on the expontential type (the function type).
***** Typing context
Typing context is a tuple that contains the term and it's type, it looks like this: ~ℾ~.
***** Back to the abstraction function
Abstraction in the tagless-final paper is just curry but it's type arguments ~a~ and ~b~ are flipped, I prefer to use the curry semantics, rather than add new functions, so we must consider that the typing context is unsual where the type identifer is the first and the added argument is the second.
exl extracts the first element of the tuple and we use the second argument of abstraction to apply the function therefore we gat a function ~a -> b~.
#+begin_src haskell
⟦abstraction e1⟧ = curry ⟦e1⟧
#+end_src
**** Applications
***** △ operator

The ~△~ operator takes in two terms and constructs a function that is a tuple of those functions, we can specify it as:
#+begin_src haskell
f ~△ g = \x -> (f x, g x)
#+end_src
It's notion is in cartesian part of CCC and it's the introduction form, cartesian adds products to the category.
***** (.)
Simple composition.
The composition primitive is necessary for a category to be a category so we can use this primitive.
***** apply
~apply~ is a function that takes in a tuple and apply's the first term to the
second.
~apply~ is in the closed part of CCC.
***** Back to application
We have what we need to make denotation.
#+begin_src haskell
⟦application a b⟧ = apply . ⟦a⟧ △ ⟦b⟧
#+end_src
**** Constructors
In Compiling With Categories, Conal shows that constructors is equivalent to the defined const function which has three parts:
***** It
~it~ is described in the function category where it's a morphism from any object to the terminal object where:
#+begin_src haskell
it :: \a -> ()
#+end_src
***** (.)
Simple composition.
***** unitArrow
In unitArrow, you reverse the type signature of ~it~ to be:
#+begin_src haskell
unitArrow :: \() -> a
#+end_src
***** flip
~flip~ is the function that flips two arguments in a binary operation.
***** Back to constructors
Now that we have all the primitives necessary we can build the constructor denotation to be just:

#+begin_src haskell
⟦constructor⟧ :: Lambda (wrap p b) => wrap p b -> Function p b
⟦constructor p b⟧  = ⟦flip⟧ (const ⟦b⟧)
#+end_src

**** Pair
The ~△~ corresponds perfectly as the introduction form to the pair.
#+begin_src haskell
⟦pair e1 e2⟧ = ⟦e1⟧ △ ⟦e2⟧
#+end_src
All the functions concerning products is the cartesian part of the CCC, which has introduction and projections.
**** Fst
Fst is exl.

#+begin_src haskell
⟦fst e1⟧ = exl ⟦e1⟧  
#+end_src
**** Snd
Snd is exr
#+begin_src haskell
⟦snd e1⟧ = exr ⟦e1⟧  
#+end_src
*** The full picture
This shows the complete denotation, I think it shows the beauty and elegance of denotational design, combined with literate programming, I hope you enjoyed reading it as much as I have written it.
#+begin_src haskell
⟦_⟧ :: Lambda (wrap a b) => wrap a b -> (a -> b)
⟦abstraction e1⟧ = curry ⟦e1⟧
⟦application a b⟧ = apply . ⟦a⟧ △ ⟦b⟧
⟦constructor b⟧  = ⟦flip⟧ (const ⟦b⟧)
⟦pair e1 e2⟧ = ⟦e1⟧ △ ⟦e2⟧
⟦fst e1⟧ = exl ⟦e1⟧
⟦snd e1⟧ = exr ⟦e1⟧  
#+end_src

* Implementation
** Infrastructure
*** Muli-line
#+begin_src haskell
:set +m
#+end_src

#+RESULTS:

** Essential State
*** Types
# While, the function category is the semantic domain, we need a way to capture get those parameters, R is representially identical to the function type and it gives us the unR function which lets use that data at will.
The main type that we are going to use is the function type ~(->)~, it comes built in with Haskell.
*** Relations
In the out of the tar pit paper, the authors suggest only using relations and more generally the relational algebra for the state part of a program, we adhere to the paper by using record types analogously as relations.
As I said before, record types in Haskell can be analogous to relations (tables in SQL), infact, this approach is used in Persistent which is the most popular ORM in Haskell and the native Haskell database Project-M36 (check this project out, it's really underrated).
The main relation is the ~R~ relation which has one pair, ~unR~ is the attribute's name and it's type is the function type.
Let's define it:
#+begin_src haskell
data R h a = R {unR :: h -> a}
#+end_src

#+RESULTS:

The ~R~ relation is actually isomorphic to the function type since they are representially the same.
** Essential Logic
*** AST
**** Classes
Expr is the AST of the Ari language, as I have have said before, Ari uses tagless-final so functions instead of an ADT to descibe an AST. 

#+begin_src haskell
class AST wrap where
  abstraction :: wrap (h, a) b -> wrap h (a -> b)
  application :: wrap env (a -> b) -> wrap env a -> wrap env b
  pair :: wrap env a -> wrap env b -> wrap env (a, b)

-- Necessary comment for the where clause to be closed, ob-haskell should be improved :)
#+end_src

#+RESULTS:


**** Instance

Since we are doing the AST, the tagless-final way, the design and implementation are actually not that different which I find to be so beautiful.
***** Helper functions
Helper functions that will make the code cleaner.
#+begin_src haskell
apply (f, x) = f x
triangle f g = \x -> (f x, g x)
fe1 e1 = \x -> (unR e1 x)
fe2 e2 = \x -> (unR e2 x)

#+end_src

#+begin_src haskell
instance AST R where
  abstraction e1 = R $ curry (unR e1)
  application e1 e2 = R $ apply . (triangle fe1 fe2)
  pair e1 e2 = R $ triangle fe1 fe2
    where
      apply (f, x) = f x
      triangle f g = \x -> (f x, g x)
      fe1 = \x -> (unR e1 x)
      fe2 = \x -> (unR e2 x)


-- T
#+end_src

#+RESULTS:
#+begin_example
ghci| ghci| ghci| ghci| ghci| ghci| ghci| ghci| ghci| 
<interactive>:451:45-47: error:
    • Couldn't match type ‘env’ with ‘R (h0 -> b) b’
      Expected: env -> (h0 -> b) -> b
        Actual: R (h0 -> b) b -> (h0 -> b) -> b
      ‘env’ is a rigid type variable bound by
        the type signature for:
          application :: forall env a b. R env (a -> b) -> R env a -> R env b
        at <interactive>:451:3-13
    • In the first argument of ‘triangle’, namely ‘fe1’
      In the second argument of ‘(.)’, namely ‘(triangle fe1 fe2)’
      In the second argument of ‘($)’, namely
        ‘apply . (triangle fe1 fe2)’
    • Relevant bindings include
        e2 :: R env a (bound at <interactive>:451:18)
        e1 :: R env (a -> b) (bound at <interactive>:451:15)
        application :: R env (a -> b) -> R env a -> R env b
          (bound at <interactive>:451:3)
#+end_example

# ** Applicationa
on
Let's start with application, application takes two terms, the first one a function and the second term you apply it to create a third term.
In tagless-final paper it's:

#+begin_src haskell
apply = 
type Function = (->)
instance Expr Function where
  application a b = apply  (\h -> triangle (a h) (b h))
  -- a
#+end_src



#+begin_src haskell
instance AST R where
  abstraction e1 e2 = apply
#+end_src


** Accidental State And Control
** Other (Interfacing)

* Footnotes
[fn:1]:
* For Stream
Added in Design, functionality.
Fixed types heading.
Done expressions off-stream.
Work on the denotation heading.
Some prose added.
